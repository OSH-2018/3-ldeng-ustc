# 内存文件系统

本程序实现了一个简单的定长（4GB）单目录的内存文件系统。
请用下列命令编译project文件夹中的``main.cpp``文件。

```
g++ -D_FILE_OFFSET_BITS=64 -o oshfs ./project/main.cpp -lfuse -std=c++14
```

## 名词定义

### 内存块

使用mmap分配的一块内存，简称为块。在本系统中大小为65536 Byte（Blocksize）。

### 信息块

用于储存filenode的内存块。这个结构大小为256 Bytes，故每个块中可储存256个节点。

### 数据块

用于储存文件内容的块。

## 类型定义

### 循环队列（Queue）

一个简单的循环队列实现，可以指定队列数据和队头、队尾的储存位置。作为模版类，可指定元素类型和最长长度。

### 哈希表（Hashmap）

一个简单实现的闭散列哈希表。可以通过std::string检索到内存位置。

### 块编号 （MemNo）

``uint16_t`` 的别名，0~65535,与内存块一一对应。由于块0有特殊定义，不会作为动态分配的块编号，定义0为（链表中的）中止编号。

### 块内位置 （BlockPos）

``uint8_t`` 的别名，0~255,与信息块中节点位置一一对应。

### 内存位置（Location）

``pair<MemNo,BlockPos>`` 的别名，用于标示某一文件节点的位置。由于数据对齐的原因，该类型大小为4 Bytes，这点需要注意。由于块0有特殊定义，不会为可用位置，定义``Location(0,0)``为（链表中的）中止位置。

### 文件节点 （Filenode）

按值（而非指针）存储了文件名（``char filename[104]``）、文件状态（``struct stat st``）、文件内容起始位置（``Location content``）以及下个文件节点位置(``Location next``)。由于对齐，结构体中的成员定义顺序不能随意更改，该结构体大小正好为256 Bytes。值得注意的是，此处限定了文件名不得超过103个字符。

### 基本信息 （BasicInfo)

储存了文件系统的基本信息的结构体。

## 块定义

本文件系统块数量一定，设为65536（Blocknr）块，从 0 至 65535 编号，记为mem[0]至mem[65536]，每块大小为65536 Byte（Blocksize）。未使用的块不分配内存，需要使用时使用mmap从内存中分配，各块定义如下。

* mem[0] ：类型：``BasicInfo`` ，储存整个系统共用的信息。 
* mem[1] - mem[2] ：类型：``Queue<MemNo>`` ，循环队列，储存未被使用的块编号。
* mem[3] - mem[6] ：类型：``Queue<Location>``，循环队列，储存被分配为信息块的块中未被使用的内存位置。
* mem[7] ：类型：``uint8_t[Blocknr]``，引用计数，被分配为信息块的内存块中已使用的位置数量，用于回收利用。溢出不可怕，强行使用它。0既可以代表256也可以代表0,根据是新写入信息后还是新删除信息后来判断。这个计数不用与判断位置是否被使用，只用于判断整个块是否为全空。
* mem[8] - mem[9] ：类型：``MemNo[Blocknr]``，nextBlock线性表，储存作为文件数据块的链表数据，即对应编号数据块在数据上连续的块编号，若无则置为0。
* mem[10] - mem[15] ：类型：``Hashmap``，哈希表，用于文件名到文件位置的检索。
* mem[16] - mem[65535] ：无特定用处的块，将会被分配为数据块或信息块

## 思路、算法和数据结构

本项目使用1个链表（不包括数据链表）、2个队列、2个线性表及1个哈希表共同维护一个单目录文件系统。具体用途如下：

### 链表

在BasicInfo中记录头节点，由Filenode作为元素的链表。该链表维护整个目录下所有文件节点（每个文件节点对应一个文件），链表中的指针全部由自定义的类型``Location``通过块编号和块内位置确定（见类型定义部分）。每个块中最多可储存256个文件节点（故块内位置有256个）。

### 可用位置队列、引用计数

由一个元素为``Location``的循环队列维护当前可以使用的文件节点信息位置。当需要创建新的节点时，从队列中取出一个元素作为存放位置。当队列为空，分配新的块作为信息块，并将块中256个位置推入队列。当销毁文件节点时，将其位置加入队列。
为了回收利用信息块，使用一个线性表对每个信息块进行引用计数。当销毁文件节点时，若该信息块引用计数减为0,说明该块中所有位置都不再被使用，此时将该块回收利用（具体方法见可用块队列）。回收信息块时，位置队列中的相应位置不会同时被回收，但每次从位置队列中分配新的heishi时，要判断该位置是否失效（引用计数为0且不是新分配的块则为失效），失效位置将被直接跳过。

### 可用块队列

由一个元素为``MemNo``的循环队列维护当前可用的块。需要分配信息块或数据块时，从队列中取出编号，给分配相应块分配内存。当截断、销毁文件时，将可回收的对应块编号压入队列，并释放内存。当需要分配块而队列为空，返回空间不足错误。初始化时应将除了固定用途的块以外的编号全部压入队列中。

### 数据链表、nextBlock线性表

每一个文件节点都储存了一个MemNo字段，记录了该文件节点数据开头所在块。而所有数据通过文件节点的状态字段``st``内``st_size``字段和一个数据链表共同确定。而所有数据链表的next指针定义在nextBlock线性表中。若一个块为数据块，且不为该文件的中止块，则nextBlock中对应位置记录下一块的块编号，否则记录0。

### 哈希表

为了加快查找速度，使用hash表加速文件节点的查找。在文件名两两不同的情况下，通过文件名的hash值作为查找依据，可大大加快查找速度。为了放置在文件数量较多时查找时间退化，将hash的桶大小设为``Blocknr*2-1``。这是一个质数。

### 算法及复杂度

算法如上所述，在对应操作时维护上列数据结构即可，故期望事件复杂度如下（b代表文件包含数据块数，n代表文件系统总文件数）：

* 系统初始化：O(Blocknr)
* 创建文件：O(1)
* 删除文件：O(b)
* 截断文件：O(b)
* 写文件：O(b)
* 读文件：O(b)
* 读取文件信息：O(1)
* 读目录：O(n)

效率值得信赖。